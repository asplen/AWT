*******************************************************************************
Простое приложение Swing
_______________________________________
Программы Swing отличаются как от консольных программ,
так и от программ на основе AWT.

Например, в них используется другой набор компонентов и другая иерархия контейнеров, нежели в
программах AWT.

Программы Swing также предъявляют особые требования
касательно многопоточности.

Лучший способ понять структуру программы
Swing - исследовать ее пример.

Прежде чем начать, важно отметить, что в
прошлом существовало два вида программ на Java, в которых обычно
применялась инфраструктура Swing.

Первый вид - настольное приложение, который используется повсеместно и рассматривается здесь.
Второй вид - аплет (не обсуждаются).

Несмотря на краткость следующей программы, в ней представлен один
из способов написания приложения Swing и продемонстрировано несколько
ключевых средств Swing. В программе применяются два компонента Swing:

JFrame и JLabel.

Класс JFrame является контейнером верхнего уровня,
а класс JLabel - компонентом Swing, создающим метку,
которая представляет собой компонент, отображающий информацию.

Метка - простейший компонент Swing, потому
что она пассивна, т.е. не реагирует на пользовательский ввод,
просто отображая выходные данные.

Для хранения экземпляра JLabel в программе применяется контейнер JFrame.
Метка отображает короткое текстовое сообщение.
*******************************************************************************
Поскольку программа SwingDemo иллюстрирует несколько ключевых концепций Swing,
давайте ее внимательно проанализируем, строка за строкой.

Программа начинается с импорта javax.swing.

Как уже упоминалось, пакет
javax.swing содержит компоненты и модели, определенные инфраструктурой Swing.

Например, в javax.swing определены классы, реализующие метки, кнопки, текстовые
элементы управления и меню. Он будет включаться во все программы на базе Swing.

Затем в программе объявляется класс SwingDemo и конструктор для него.

В конструкторе происходит большая часть действий программы.
Сначала создается экземпляр JFrarne:
JFrame jfrm = new JFrame ( "А Simple Swing Application" );

Здесь создается контейнер по имени jfrm, который определяет прямоугольное окно с заголовком,
кнопками закрытия, сворачивания, разворачивания и восстановления, а также системным меню.

В итоге получается стандартное окно верхнего уровня.

Конструктору передается заголовок окна.

Далее задаются размеры окна:
jfrm.setSize (275, 100) ;

Метод setSize (), унаследованный классом JFrarne от класса Component
из библиотеки AWT, устанавливает размеры окна, указанные в пикселях.
Вот его общая форма:

void setSize (int width, int height)

В текущем примере ширина (width) окна устанавливается в 275, а высота
(height) - в 100.

По умолчанию, когда окно верхнего уровня закрывается (например,
по щелчку пользователем на кнопке закрытия), оно удаляется с экрана,
но приложение не прекращает работу.

Хотя в некоторых ситуациях такое стандартное поведение удобно, в большинстве приложений
в нем нет необходимости.

Взамен обычно нужно, чтобы при закрытии окна верхнего
уровня приложение завершалось. Добиться желаемого можно несколькими способами,
из которых самый простой предусматривает вызов метода
setDefaultCloseOperation (), как сделано в программе:

jfrm. setDefaultCloseOperation (JFrame .EXIT_ON_CLOSE);

После выполнения этого вызова закрытие окна приводит к прекращению работы всего приложения.

Общая форма метода setDefaultCloseOperation ()
выглядит следующим образом:

void setDe faultCloseOperation ( int what )

Передаваемое в what значение определяет, что происходит при закрытии окна.

Помимо JFrame. EXIT_ON_CLOSE есть ряд других вариантов:
DISPOSE_ON_CLOSE
HIDE_ON_CLOSE
DO_NOTHING_ON_CLOSE

Их имена отражают выполняемые действия (освобождать при закрытии,
скрыть при закрытии и ничего не делать при закрытии).
Упомянутые константы объявлены в интерфейсе WindowConstants из javax.swing,
который реализован классом JFrame.


Далее создается компонент JLabel инфраструктуры Swing:

JLabel jlab = new JLabel (" Swing means powerful GUis. ");

Класс JLabel - самый простой и легкий в использовании компонент, т.к.
он не принимает пользовательский ввод, а просто отображает информацию,
которая может состоять из текста, значка либо их комбинации.
Метка, созданная программой, содержит только текст, который передается ее конструктору.

В следующей строке кода метка добавляется в панель содержимого фрейма:

jfrm.add(jlab);

Как объяснялось ранее, все контейнеры верхнего уровня имеют панель содержимого,
в которой хранятся компоненты.
Таким образом, для помещения компонента во фрейм необходимо добавить его в
панель содержимого фрейма, вызвав метод add () на ссылке JFrame (в данном случае jfrm).
Вот общая форма метода add () :

Component add (Component соmp)

Метод add () наследуется классом JFrame от класса Container из библиотеки AWT.

По умолчанию панель содержимого, связанная с JFrame, применяет граничную компоновку.

Только что показанная форма add () добавляет метку
в центральную область.

Другие формы метода add () позволяют указывать
одну из областей граничной компоновки.

Когда компонент добавляется в центральную область, его размеры автоматически
подстраиваются под размеры центральной области.

Прежде чем продолжить, нужно сделать важное замечание исторического характера.

До выхода JDK 5 при добавлении компонента в панель
содержимого нельзя было вызывать метод add () непосредственно на экземпляре JFrame.

Взамен add () требовалось вызывать на панели содержимого экземпляра JFrame.
Панель содержимого можно было получить,
вызвав getContentPane () на экземпляре JFrame.
Ниже показан метод getContentPane () :

Container getContentPane ()

Он возвращает ссылку Container на панель содержимого. Затем для этой
ссылки вызывался метод add( ), чтобы добавить компонент в панель содержимого.
Таким образом, в прошлом для добавления jlab в jfrm приходилось
использовать следующий оператор:

jfrm. getContentPane () .add (jlab) ; // старый стиль

Сначала с помощью метода getContentPane () получается ссылка на панель содержимого,
после чего посредством add () компонент добавляется в
контейнер, связанный с данной панелью.

Аналогичная процедура требовалась
также при вызове метода remove() для удаления компонента и при вызове
метода setLayout () для установки диспетчера компоновки, относящегося к
панели содержимого.

Вот почему в унаследованном коде, написанном до появления JDK 5,
часто встречаются явные вызовы getContentPane (). Теперь
применять getContentPane () больше не нужно.
Можно просто вызывать add (), remove () и setLayout () прямо на JFrame, потому что эти методы
были изменены таким образом, что они автоматически работают с панелью
содержимого.

Последний оператор в конструкторе SwingDemo делает окно видимым:
jfrm.setVisble (true) ;

Метод setVisible () унаследован от класса Component из AWT. Если его
аргумент равен true, то окно будет отображено, а если false, тогда скрыто.
По умолчанию компонент JFrame невидимый, так что для его отображения
необходимо вызвать setVisible (true).

Внутри метода main () создается объект SwingDemo, который обеспечивает отображение окна и метки.

Обратите внимание на то, как вызывается конструктор SwingDemo:
SwingUtilities.invokeLater(new Runnable() {
            public void run() {new SwingDemo();}
        });

Приведенная кодовая последовательность создает объект SwingDemo в
потоке диспетчеризаиции событий, а не в главном потоке приложения. Дело в
том, что программы Swing обычно управляются событиями.
Например, при взаимодействии пользователя с компонентом генерируется событие.

Событие передается приложению путем вызова обработчика событий, определенного
приложением. Обработчик выполняется в потоке диспетчеризации событий, предоставляемом Swing,
а не в главном потоке приложения.

Таким образом, хотя обработчики событий определены в программе, вызываются они в потоке,
который программой не создавался.
Во избежание проблем (включая потенциальную взаимоблокировку) все
компоненты графического пользовательского интерфейса Swing должны создаваться и
обновляться из потока диспетчеризации событий, а не из главного потока приложения.

Однако метод main () выполняется в главном потоке.
Таким образом, main () не может напрямую создавать объект SwingDemo.

Взамен он должен создать объект Runnable, который выполняется в потоке
диспетчеризации событий, и поручить этому объекту создание графического
пользовательского интерфейса.

Чтобы разрешить создание кода графического пользовательского интерфейса
в потоке диспетчеризации событий, необходимо воспользоваться одним из двух методов,
определенных в классе SwingUtilities - invokeLater () и invokeAndWait():

static void invokeLater ( RunnaЬle obj )
static void invokeAndWait ( RunnaЬle obj ) throws InterruptedException, InvocationTargetException

В obj передается объект Runnable, метод run () которого будет вызываться потоком диспетчеризации событий.
Разница между указанными двумя методами в том, что invokeLater () возвращает значение немедленно,
а invokeAndWait() ожидает возврата управления из obj.run ().

Один из этих методов можно применять для вызова метода, создающего
графический пользовательский интерфейс приложения Swing, или всякий раз,
когда нужно изменить состояние графического пользовательского интерфейса из кода,
не выполняющегося в потоке диспетчеризации событий.

Обычно будет использоваться invokeLater (), как делалось в предыдущей программе.
При конструировании начального графического пользовательского интерфейса для
аплета требуется метод invokeAndWait ().
Таким образом, его часто можно встретить в унаследованном коде аплетов.